#include <Alchemy/database/file.hxx>
#include <Alchemy/database/sqlite3.hxx>
#include <Alchemy/media/file.hxx>
#include <Alchemy/media/audio/stream.hxx>
#include <Alchemy/media/video/stream.hxx>
#include <Alchemy/media/subtitle/stream.hxx>
#include "generated/database_create.hxx" // Autogenerated by CMake

#include <stdexcept>

using namespace Alchemist::Database;

const std::map<std::string, std::string> SQLite3::DATABASE_PREPARED_SENTENCES = {
	{ "new_film",					"INSERT INTO films(in_file, in_size, out_file, priority) VALUES (?, ?, ?, ?) RETURNING film_id"	},
	{ "new_stream",					"INSERT INTO streams(film_id, stream_id, stream_type, title, lang) VALUES (?, ?, ?, ?, ?)"		},
	{ "new_meta_audio",				"INSERT INTO stream_metadata_audio(film_id, stream_id, codec, sample_rate, channels) VALUES (?, ?, ?, ?, ?)"					},
	{ "new_meta_video",				"INSERT INTO stream_metadata_video(film_id, stream_id, frames, codec) VALUES (?, ?, ?, ?)"		},
	{ "new_meta_video_res",			"INSERT INTO stream_metadata_video_resolution(film_id, stream_id, width, height) VALUES (?, ?, ?, ?)" },
	{ "new_meta_video_color",		"INSERT INTO stream_metadata_video_color(film_id, stream_id, prim, matrix, transfer, pix_fmt) VALUES (?, ?, ?, ?, ?, ?)" },
	{ "new_meta_video_hdr10",		"INSERT INTO stream_metadata_video_hdr10(film_id, stream_id, red_x, red_y, green_x, green_y, blue_x, blue_y, white_x, white_y, lum_min, lum_max, light_max, light_avg, has_plus) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)" },
	{ "new_meta_subtitle",			"INSERT INTO stream_metadata_video_subtitle(film_id, stream_id, encoding) VALUES (?, ?, ?)"		},
	{ "clear_statuses",				"UPDATE films SET active = FALSE, failed = FALSE"											},
	{ "get_film_data",				"SELECT in_file, in_size, out_file, out_size, encode_time, priority, active, enabled, failed FROM films WHERE film_id = ?" },
	{ "get_film_streams",			"SELECT stream_id, stream_type, title, lang FROM streams WHERE film_id = ?"						},
	{ "get_film_meta_audio",		"SELECT codec, sample_rate, channels FROM stream_metadata_audio WHERE film_id = ? AND stream_id = ?"					},
	{ "get_film_meta_video",		"SELECT frames, codec FROM stream_metadata_video WHERE film_id = ? AND stream_id = ?"					},
	{ "get_film_meta_video_res",	"SELECT width, height FROM stream_metadata_video_resolution WHERE film_id = ? AND stream_id = ?"},
	{ "get_film_meta_video_color",	"SELECT prim, matrix, transfer, pix_fmt FROM stream_metadata_video_color WHERE film_id = ? AND stream_id = ?"	},
	{ "get_film_meta_video_hdr10",	"SELECT red_x, red_y, green_x, green_y, blue_x, blue_y, white_x, white_y, lum_min, lum_max, light_max, light_avg, has_plus FROM stream_metadata_video_hdr10 WHERE film_id = ? AND stream_id = ?" },
	{ "get_film_meta_subtitle",		"SELECT encoding FROM stream_metadata_video_subtitle WHERE film_id = ? AND stream_id = ?" },
	{ "get_film_id_for_encode",		"SELECT film_id FROM films WHERE enabled = TRUE AND active = FALSE AND out_size IS NULL ORDER BY priority ASC LIMIT 1" },
	{ "mark_film_as_active",		"UPDATE films SET active = TRUE WHERE film_id = ?" },
	{ "mark_film_as_failed",		"UPDATE films SET active = FALSE, failed = TRUE WHERE film_id = ?" },
	{ "complete_film",				"UPDATE films SET active = FALSE, failed = FALSE, out_size = ?, encode_time = ? WHERE film_id = ?" },
	{ "get_all_films",				"SELECT film_id FROM films ORDER BY film_id DESC" }
};

SQLite3::SQLite3(const std::filesystem::path& dbfile) {
	int rc = sqlite3_open(dbfile.string().c_str(), &m_database); // Windows needs this string intermediate conversion

	if (rc != SQLITE_OK) {
		const std::string message = "Cannot open database " + dbfile.string() + ": " + std::string(sqlite3_errmsg(m_database));
		sqlite3_close(m_database); // Need to close database here as exception throwing will skip destructor
        throw std::runtime_error(message);
    }
	if (!check_database()) init_database();
	enable_foreign_keys();
	prepare_sentences();
	
}

SQLite3::~SQLite3() {
	for (auto it = m_prepared.begin(); it != m_prepared.end(); it++) {
		sqlite3_finalize(it->second);
	}
	m_prepared.clear();
	sqlite3_close(m_database);
}

void SQLite3::ClearStatuses() {
	begin_exclusive_transaction();

	auto stmt = m_prepared["clear_statuses"];
	sqlite3_step(stmt);
	reset_stmt(stmt);

	commit_transaction();
}

int SQLite3::SaveFilm(const std::filesystem::path& source_file, const Media::File& outfile, const unsigned short& prio) {
	begin_exclusive_transaction();

	/* Insert Film */
	auto stmt = m_prepared["new_film"];
	sqlite3_bind_text	(stmt, 1, source_file.string().c_str(), -1, SQLITE_STATIC); // Windows needs this string intermediate conversion
	sqlite3_bind_int64	(stmt, 2, outfile.GetSize());
	sqlite3_bind_text	(stmt, 3, outfile.GetFileName().string().c_str(), -1, SQLITE_STATIC);
	sqlite3_bind_int	(stmt, 4, prio);
	sqlite3_step(stmt);
	unsigned short film_id = sqlite3_column_int(stmt, 0);
	reset_stmt(stmt);

	for (auto it = outfile.GetStreams().begin(); it != outfile.GetStreams().end(); it++) {
		/* Stream basic */
		stmt = m_prepared["new_stream"];
		const unsigned short stream_id = (*it)->GetIndex();
		const Media::Type stream_type = (*it)->GetType();
		sqlite3_bind_int	(stmt, 1, film_id);
		sqlite3_bind_int	(stmt, 2, stream_id);
		sqlite3_bind_int	(stmt, 3, static_cast<unsigned short>(stream_type));
		if ((*it)->GetTitle())
			sqlite3_bind_text	(stmt, 4, (*it)->GetTitle().value().c_str(), -1, SQLITE_STATIC);
		else
			sqlite3_bind_null	(stmt, 4);
		if ((*it)->GetLanguage())
			sqlite3_bind_text	(stmt, 5, (*it)->GetLanguage().value().c_str(), -1, SQLITE_STATIC);
		else
			sqlite3_bind_null	(stmt, 5);
		sqlite3_step(stmt);
		reset_stmt(stmt);

		switch(stream_type) {
			case Media::Type::Audio: {
				std::shared_ptr<Media::Audio::Stream> audio_stream = std::dynamic_pointer_cast<Media::Audio::Stream>(*it);
				std::shared_ptr<Media::Audio::Metadata> audio_metadata = std::dynamic_pointer_cast<Media::Audio::Metadata>(audio_stream->GetMetadata());
				stmt = m_prepared["new_meta_audio"];
				sqlite3_bind_int	(stmt, 1, film_id);
				sqlite3_bind_int	(stmt, 2, stream_id);
				sqlite3_bind_text	(stmt, 3, audio_stream->GetCodec()->GetEncoderName().c_str(), -1, SQLITE_STATIC);
				sqlite3_bind_int	(stmt, 4, audio_metadata->GetSampleRate());
				sqlite3_bind_int	(stmt, 5, audio_metadata->GetChannels());
				sqlite3_step(stmt);
				reset_stmt(stmt);
				break;
			}
			case Media::Type::Video: {
				std::shared_ptr<Media::Video::Stream> video_stream = std::dynamic_pointer_cast<Media::Video::Stream>(*it);
				std::shared_ptr<Media::Video::Metadata> video_metadata = std::dynamic_pointer_cast<Media::Video::Metadata>(video_stream->GetMetadata());
				if (video_metadata->GetFrames()) {
					stmt = m_prepared["new_meta_video"];
					sqlite3_bind_int	(stmt, 1, film_id);
					sqlite3_bind_int	(stmt, 2, stream_id);
					sqlite3_bind_int	(stmt, 3, video_metadata->GetFrames().value());
					sqlite3_bind_text	(stmt, 4, video_stream->GetCodec()->GetEncoderName().c_str(), -1, SQLITE_STATIC);
					sqlite3_step(stmt);
					reset_stmt(stmt);
				}
				if (video_metadata->GetResolution()) {
					stmt = m_prepared["new_meta_video_res"];
					sqlite3_bind_int	(stmt, 1, film_id);
					sqlite3_bind_int	(stmt, 2, stream_id);
					sqlite3_bind_int	(stmt, 3, video_metadata->GetResolution()->GetWidth());
					sqlite3_bind_int	(stmt, 4, video_metadata->GetResolution()->GetHeight());
					sqlite3_step(stmt);
					reset_stmt(stmt);
				}
				if (video_metadata->GetColor()) {
					stmt = m_prepared["new_meta_video_color"];
					sqlite3_bind_int	(stmt, 1, film_id);
					sqlite3_bind_int	(stmt, 2, stream_id);
					sqlite3_bind_text	(stmt, 3, video_metadata->GetColor()->GetPrimaries()->c_str(), -1, SQLITE_STATIC);
					sqlite3_bind_text	(stmt, 4, video_metadata->GetColor()->GetMatrix()->c_str(), -1, SQLITE_STATIC);
					sqlite3_bind_text	(stmt, 5, video_metadata->GetColor()->GetTransfer()->c_str(), -1, SQLITE_STATIC);
					sqlite3_bind_text	(stmt, 6, video_metadata->GetColor()->GetPixelFormat()->c_str(), -1, SQLITE_STATIC);
					sqlite3_step(stmt);
					reset_stmt(stmt);
				}
				if (video_metadata->GetHDR10()) {
					stmt = m_prepared["new_meta_video_hdr10"];
					sqlite3_bind_int	(stmt, 1, film_id);
					sqlite3_bind_int	(stmt, 2, stream_id);
					// red_x, red_y, green_x, green_y, blue_x, blue_y, white_x, white_y, lum_min, lum_max, light_max, light_avg, has_plus
					sqlite3_bind_int	(stmt, 3, video_metadata->GetHDR10()->GetRedPoint().first);
					sqlite3_bind_int	(stmt, 4, video_metadata->GetHDR10()->GetRedPoint().second);
					sqlite3_bind_int	(stmt, 5, video_metadata->GetHDR10()->GetGreenPoint().first);
					sqlite3_bind_int	(stmt, 6, video_metadata->GetHDR10()->GetGreenPoint().second);
					sqlite3_bind_int	(stmt, 7, video_metadata->GetHDR10()->GetBluePoint().first);
					sqlite3_bind_int	(stmt, 8, video_metadata->GetHDR10()->GetBluePoint().second);
					sqlite3_bind_int	(stmt, 9, video_metadata->GetHDR10()->GetWhitePoint().first);
					sqlite3_bind_int	(stmt, 10, video_metadata->GetHDR10()->GetWhitePoint().second);
					sqlite3_bind_int	(stmt, 11, video_metadata->GetHDR10()->GetLuminance().first);
					sqlite3_bind_int	(stmt, 12, video_metadata->GetHDR10()->GetLuminance().second);
					if (video_metadata->GetHDR10()->GetLightLevel()) {
						sqlite3_bind_int	(stmt, 13, video_metadata->GetHDR10()->GetLightLevel()->first);
						sqlite3_bind_int	(stmt, 14, video_metadata->GetHDR10()->GetLightLevel()->second);
					}
					else {
						sqlite3_bind_null	(stmt, 13);
						sqlite3_bind_null	(stmt, 14);
					}
					sqlite3_step(stmt);
					reset_stmt(stmt);
				}
				break;
			}
			case Media::Type::Subtitle: {
				std::shared_ptr<Media::Subtitle::Stream> subtitle_stream = std::dynamic_pointer_cast<Media::Subtitle::Stream>(*it);
				std::shared_ptr<Media::Subtitle::Metadata> subtitle_metadata = std::dynamic_pointer_cast<Media::Subtitle::Metadata>(subtitle_stream->GetMetadata());
				stmt = m_prepared["new_meta_subtitle"];
				sqlite3_bind_int	(stmt, 1, film_id);
				sqlite3_bind_int	(stmt, 2, stream_id);
				sqlite3_bind_text	(stmt, 3, subtitle_metadata->GetString().c_str(), -1, SQLITE_STATIC);
				sqlite3_step(stmt);
				reset_stmt(stmt);
				break;
			}
			default:
				break;
		}
	}

	commit_transaction();
	return film_id;
}

std::shared_ptr<File> SQLite3::GetFilm(const unsigned int& film_id) {
	std::shared_ptr<File> film;
	auto stmt = m_prepared["get_film_data"];
	sqlite3_bind_int(stmt, 1, film_id);
	if (sqlite3_step(stmt) == SQLITE_ROW) {
		film = std::make_shared<File>();
		film->SetInFile(std::string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0))));
		film->SetInSize(sqlite3_column_int(stmt, 1));
		film->SetOutFile(std::string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 2))));
		if (sqlite3_column_type(stmt, 3) != SQLITE_NULL)
			film->SetOutSize(sqlite3_column_int(stmt, 3));
		if (sqlite3_column_type(stmt, 4) != SQLITE_NULL)
			film->SetEncodeTime(sqlite3_column_int(stmt, 4));
		film->SetPriority(sqlite3_column_int(stmt, 5));
		film->SetActiveStatus(static_cast<bool>(sqlite3_column_int(stmt, 6)));
		film->SetEnabledStatus(static_cast<bool>(sqlite3_column_int(stmt, 7)));
		film->SetFailedStatus(static_cast<bool>(sqlite3_column_int(stmt, 8)));
		reset_stmt(stmt);

		/* Streams */
		stmt = m_prepared["get_film_streams"];
		sqlite3_bind_int(stmt, 1, film_id);
		while (sqlite3_step(stmt) != SQLITE_DONE) {
			const unsigned short stream_index = sqlite3_column_int(stmt, 0);
			const std::string stream_type = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));
			const std::string stream_title = (sqlite3_column_type(stmt, 2) != SQLITE_NULL) ? reinterpret_cast<const char*>(sqlite3_column_text(stmt, 2)) : "";
			const std::string stream_language = (sqlite3_column_type(stmt, 3) != SQLITE_NULL) ? reinterpret_cast<const char*>(sqlite3_column_text(stmt, 3)) : "";
			
			if (stream_type == "a") {
				std::shared_ptr<Media::Audio::Stream> stream = std::make_shared<Media::Audio::Stream>(stream_index);
				auto stmt_audio = m_prepared["get_film_meta_audio"];
				sqlite3_bind_int(stmt_audio, 1, film_id);
				sqlite3_bind_int(stmt_audio, 2, stream_index);
				if (sqlite3_step(stmt_audio) == SQLITE_ROW) {
					const std::string codec = reinterpret_cast<const char*>(sqlite3_column_text(stmt_audio, 0));
					stream->SetCodec(Media::Audio::Codec::All.at(codec));
					stream->SetMetadata(
						{
							static_cast<unsigned short>(sqlite3_column_int(stmt_audio, 1)),
							static_cast<unsigned short>(sqlite3_column_int(stmt_audio, 2))
						}
					);
					reset_stmt(stmt_audio);
					film->AddStream(stream);
				}
			}
			else if (stream_type == "v") {
				std::shared_ptr<Media::Video::Stream> stream = std::make_shared<Media::Video::Stream>(stream_index);
				Media::Video::Metadata metadata;
				auto stmt_video = m_prepared["get_film_meta_video"];
				sqlite3_bind_int(stmt_video, 1, film_id);
				sqlite3_bind_int(stmt_video, 2, stream_index);
				if (sqlite3_step(stmt_video) == SQLITE_ROW) {
					metadata.SetFrames(sqlite3_column_int(stmt_video, 0));
					stream->SetCodec(Media::Video::Codec::All.at(reinterpret_cast<const char*>(sqlite3_column_text(stmt_video, 1))));
				}
				reset_stmt(stmt_video);
				stmt_video = m_prepared["get_film_meta_video_res"];
				sqlite3_bind_int(stmt_video, 1, film_id);
				sqlite3_bind_int(stmt_video, 2, stream_index);
				if (sqlite3_step(stmt_video) == SQLITE_ROW) {
					metadata.SetResolution(
						{
							static_cast<unsigned short>(sqlite3_column_int(stmt_video, 0)),
							static_cast<unsigned short>(sqlite3_column_int(stmt_video, 1))
						}
					);
				}
				reset_stmt(stmt_video);
				stmt_video = m_prepared["get_film_meta_video_color"];
				sqlite3_bind_int(stmt_video, 1, film_id);
				sqlite3_bind_int(stmt_video, 2, stream_index);
				if (sqlite3_step(stmt_video) == SQLITE_ROW) {
					metadata.SetColor(
						{
							reinterpret_cast<const char*>(sqlite3_column_text(stmt_video, 0)),
							reinterpret_cast<const char*>(sqlite3_column_text(stmt_video, 1)),
							reinterpret_cast<const char*>(sqlite3_column_text(stmt_video, 2)),
							reinterpret_cast<const char*>(sqlite3_column_text(stmt_video, 3)),
						}
					);
				}
				reset_stmt(stmt_video);
				stmt_video = m_prepared["get_film_meta_video_hdr10"];
				sqlite3_bind_int(stmt_video, 1, film_id);
				sqlite3_bind_int(stmt_video, 2, stream_index);
				if (sqlite3_step(stmt_video) == SQLITE_ROW) {
					Media::Video::HDR10 hdr10(
						{
							{ static_cast<unsigned short>(sqlite3_column_int(stmt_video, 0)), static_cast<unsigned short>(sqlite3_column_int(stmt_video, 1)) },
							{ static_cast<unsigned short>(sqlite3_column_int(stmt_video, 2)), static_cast<unsigned short>(sqlite3_column_int(stmt_video, 3)) },
							{ static_cast<unsigned short>(sqlite3_column_int(stmt_video, 4)), static_cast<unsigned short>(sqlite3_column_int(stmt_video, 5)) },
							{ static_cast<unsigned short>(sqlite3_column_int(stmt_video, 6)), static_cast<unsigned short>(sqlite3_column_int(stmt_video, 7)) },
							{ static_cast<unsigned short>(sqlite3_column_int(stmt_video, 8)), sqlite3_column_int(stmt_video, 9) }
						}
					);
					if (sqlite3_column_type(stmt_video, 10) != SQLITE_NULL && sqlite3_column_type(stmt_video, 11) != SQLITE_NULL)
						hdr10.SetLightLevel(
							{
								static_cast<unsigned short>(sqlite3_column_int(stmt_video, 10)), static_cast<unsigned short>(sqlite3_column_int(stmt_video, 11))
							}
						);
					if (static_cast<bool>(sqlite3_column_int(stmt_video, 12)))
						hdr10.SetPlusFile("yes"); // File will be corrected by converter
					metadata.SetHDR10(std::move(hdr10));
				}
				reset_stmt(stmt_video);
				stream->SetMetadata(std::move(metadata));
				film->AddStream(stream);
			}
			else if (stream_type == "s") {
				std::shared_ptr<Media::Subtitle::Stream> stream = std::make_shared<Media::Subtitle::Stream>(stream_index);
				auto stmt_subtitle = m_prepared["get_film_meta_subtitle"];
				sqlite3_bind_int(stmt_subtitle, 1, film_id);
				sqlite3_bind_int(stmt_subtitle, 2, stream_index);
				if (sqlite3_step(stmt_subtitle) == SQLITE_ROW) {
					stream->SetMetadata({ reinterpret_cast<const char*>(sqlite3_column_text(stmt_subtitle, 0)) });
				}
				reset_stmt(stmt_subtitle);
				film->AddStream(stream);
			}
		}
		reset_stmt(stmt);
	}
	return film;
}

std::shared_ptr<File> SQLite3::GetFilm() {
	begin_exclusive_transaction();

	auto stmt = m_prepared["get_film_id_for_encode"];
	std::shared_ptr<File> film;
	if (sqlite3_step(stmt) == SQLITE_ROW) {
		int film_id = sqlite3_column_int(stmt, 0);
		film = GetFilm(film_id);
		reset_stmt(stmt);

		stmt = m_prepared["mark_film_as_active"];
		sqlite3_bind_int(stmt, 1, film_id);
		sqlite3_step(stmt);
		reset_stmt(stmt);
	}
	else
		reset_stmt(stmt);

	commit_transaction();
	return film;
}

void SQLite3::SetAsFailed(const File& film) {
	begin_exclusive_transaction();

	auto stmt = m_prepared["mark_film_as_failed"];
	sqlite3_bind_int(stmt, 1, film.GetFilmID());
	sqlite3_step(stmt);
	reset_stmt(stmt);

	commit_transaction();
}

void SQLite3::SetAsCompleted(const File& film) {
	begin_exclusive_transaction();

	auto stmt = m_prepared["complete_film"];
	sqlite3_bind_int64(stmt, 1, *film.GetOutSize());
	sqlite3_bind_int(stmt, 2, *film.GetEncodeTime());
	sqlite3_bind_int(stmt, 3, film.GetFilmID());
	sqlite3_step(stmt);
	reset_stmt(stmt);

	commit_transaction();
}

std::list<std::shared_ptr<File>> SQLite3::GetAllFilms() {
	begin_exclusive_transaction();

	auto stmt = m_prepared["get_all_films"];
	std::list<std::shared_ptr<File>> films;
	while (sqlite3_step(stmt) == SQLITE_ROW)
		films.push_back(GetFilm(sqlite3_column_int(stmt, 0)));
	reset_stmt(stmt);

	commit_transaction();
	return films;
}

bool SQLite3::check_database() {
	char* err_msg = NULL;
	int rc = sqlite3_exec(m_database, "SELECT * FROM films;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
	return rc == SQLITE_OK;
}

void SQLite3::init_database() {
	char* err_msg = NULL;
	int rc = sqlite3_exec(m_database, DATABASE_CREATE_SQL.c_str(), nullptr, nullptr, &err_msg);
	if (rc != SQLITE_OK) throw_error(err_msg);
}

void SQLite3::enable_foreign_keys() {
	char* err_msg = NULL;
	sqlite3_exec(m_database, "PRAGMA foreign_keys = OFF", nullptr, nullptr, &err_msg);
}

void SQLite3::throw_error(char* err_msg) {
	const std::string message = "Error creating database: " + std::string(err_msg);
	sqlite3_free(err_msg);
	throw std::runtime_error(message);
}

void SQLite3::reset_stmt(sqlite3_stmt* stmt) {
	sqlite3_clear_bindings(stmt);
	sqlite3_reset(stmt);
}

void SQLite3::begin_transaction() {
	char* err_msg = nullptr;
	sqlite3_exec(m_database, "BEGIN TRANSACTION;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
}

void SQLite3::begin_exclusive_transaction() {
	char* err_msg = nullptr;
	sqlite3_exec(m_database, "BEGIN EXCLUSIVE TRANSACTION;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
}

void SQLite3::commit_transaction() {
	char* err_msg = nullptr;
	sqlite3_exec(m_database, "COMMIT;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
}

void SQLite3::rollback_transaction() {
	char* err_msg = nullptr;
	sqlite3_exec(m_database, "ROLLBACK;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
}

void SQLite3::prepare_sentences() {
	for (auto it = DATABASE_PREPARED_SENTENCES.begin(); it != DATABASE_PREPARED_SENTENCES.end(); it++) {
		m_prepared[it->first] = nullptr;
		sqlite3_prepare_v2( m_database, it->second.c_str(), static_cast<int>(it->second.length()), &m_prepared[it->first], nullptr);
		if (!m_prepared[it->first])
			throw std::runtime_error("Prepared sentence " + (it->first) + " can not be loaded!");
	}
}
