#include "../media/file.hxx"
#include "../media/audio/stream.hxx"
#include "../media/video/stream.hxx"
#include "../media/subtitle/stream.hxx"
#include "sqlite3.hxx"
#include "generated/database_create.hxx" // Autogenerated by CMake

#include <stdexcept>

using namespace Alchemist::Database;

const std::map<std::string, std::string> SQLite3::DATABASE_PREPARED_SENTENCES = {
	{ "new_film",				"INSERT INTO films(in_file, in_size, out_file, priority) VALUES (?, ?, ?, ?) RETURNING film_id"	},
	{ "new_stream",				"INSERT INTO streams(film_id, stream_id, stream_type, title, lang) VALUES (?, ?, ?, ?, ?)"		},
	{ "new_meta_audio",			"INSERT INTO stream_metadata_audio(film_id, stream_id, codec) VALUES (?, ?, ?)"					},
	{ "new_meta_video",			"INSERT INTO stream_metadata_video(film_id, stream_id, frames) VALUES (?, ?, ?)"				},
	{ "new_meta_video_res",		"INSERT INTO stream_metadata_video_resolution(film_id, stream_id, width, height) VALUES (?, ?, ?, ?)" },
	{ "new_meta_video_color",	"INSERT INTO stream_metadata_video_color(film_id, stream_id, prim, matrix, transfer, pix_fmt) VALUES (?, ?, ?, ?, ?, ?)" },
	{ "new_meta_video_hdr10",	"INSERT INTO stream_metadata_video_hdr10(film_id, stream_id, red_x, red_y, green_x, green_y, blue_x, blue_y, white_x, white_y, lum_min, lum_max, light_max, light_avg, has_plus) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)" },
	{ "new_meta_subtitle",		"INSERT INTO stream_metadata_video_subtitle(film_id, stream_id, encoding) VALUES (?, ?, ?)"		},
	{ "clear_statuses",			"UPDATE films SET active = FALSE, failed = FALSE"											},
	{ "get_film_data",			"SELECT in_file, in_size, out_file, out_size, encode_time, priority, active, enabled, failed FROM films WHERE film_id = ?" }
};

SQLite3::SQLite3(const std::filesystem::path& dbfile) {
	int rc = sqlite3_open(dbfile.c_str(), &m_database);

	if (rc != SQLITE_OK) {
		const std::string message = "Cannot open database " + dbfile.string() + ": " + std::string(sqlite3_errmsg(m_database));
		sqlite3_close(m_database); // Need to close database here as exception throwing will skip destructor
        throw std::runtime_error(message);
    }
	if (!check_database()) init_database();
	enable_foreign_keys();
	prepare_sentences();
	
}

SQLite3::~SQLite3() {
	for (auto it = m_prepared.begin(); it != m_prepared.end(); it++) {
		sqlite3_finalize(it->second);
	}
	m_prepared.clear();
	sqlite3_close(m_database);
}

void SQLite3::ClearStatuses() {
	begin_exclusive_transaction();

	auto stmt = m_prepared["clear_statuses"];
	sqlite3_step(stmt);
	reset_stmt(stmt);

	commit_transaction();
}

int SQLite3::SaveFilm(const std::filesystem::path& source_file, const Media::File& outfile, const unsigned short& prio) {
	begin_exclusive_transaction();

	/* Insert Film */
	auto stmt = m_prepared["new_film"];
	sqlite3_bind_text	(stmt, 1, source_file.c_str(), -1, SQLITE_STATIC);
	sqlite3_bind_int64	(stmt, 2, outfile.GetSize());
	sqlite3_bind_text	(stmt, 3, outfile.GetFileName().c_str(), -1, SQLITE_STATIC);
	sqlite3_bind_int	(stmt, 4, prio);
	sqlite3_step(stmt);
	unsigned short film_id = sqlite3_column_int(stmt, 0);
	reset_stmt(stmt);

	for (auto it = outfile.GetStreams().begin(); it != outfile.GetStreams().end(); it++) {
		/* Stream basic */
		stmt = m_prepared["new_stream"];
		const unsigned short stream_id = (*it)->GetIndex();
		const std::string stream_type = (*it)->GetType();
		sqlite3_bind_int	(stmt, 1, film_id);
		sqlite3_bind_int	(stmt, 2, stream_id);
		sqlite3_bind_text	(stmt, 3, stream_type.c_str(), -1, SQLITE_STATIC);
		if ((*it)->GetTitle())
			sqlite3_bind_text	(stmt, 4, (*it)->GetTitle().value().c_str(), -1, SQLITE_STATIC);
		else
			sqlite3_bind_null	(stmt, 4);
		if ((*it)->GetLanguage())
			sqlite3_bind_text	(stmt, 5, (*it)->GetLanguage().value().c_str(), -1, SQLITE_STATIC);
		else
			sqlite3_bind_null	(stmt, 5);
		sqlite3_step(stmt);
		reset_stmt(stmt);

		if (stream_type == "a") {
			/* Audio Stream Metadata */
			std::shared_ptr<Media::Audio::Stream> audio_stream = std::dynamic_pointer_cast<Media::Audio::Stream>(*it);
			stmt = m_prepared["new_meta_audio"];
			sqlite3_bind_int	(stmt, 1, film_id);
			sqlite3_bind_int	(stmt, 2, stream_id);
			sqlite3_bind_text	(stmt, 3, audio_stream->GetCodec()->GetEncoderName().c_str(), -1, SQLITE_STATIC);
			sqlite3_step(stmt);
			reset_stmt(stmt);
		}
		else if (stream_type == "v") {
			/* Video Stream Metadata */
			std::shared_ptr<Media::Video::Stream> video_stream = std::dynamic_pointer_cast<Media::Video::Stream>(*it);
			std::shared_ptr<Media::Video::Metadata> video_metadata = std::dynamic_pointer_cast<Media::Video::Metadata>(video_stream->GetMetadata());
			if (video_metadata->GetFrames()) {
				stmt = m_prepared["new_meta_video"];
				sqlite3_bind_int	(stmt, 1, film_id);
				sqlite3_bind_int	(stmt, 2, stream_id);
				sqlite3_bind_int	(stmt, 3, video_metadata->GetFrames().value());
				sqlite3_step(stmt);
				reset_stmt(stmt);
			}
			if (video_metadata->GetResolution()) {
				stmt = m_prepared["new_meta_video_res"];
				sqlite3_bind_int	(stmt, 1, film_id);
				sqlite3_bind_int	(stmt, 2, stream_id);
				sqlite3_bind_int	(stmt, 3, video_metadata->GetResolution()->GetWidth());
				sqlite3_bind_int	(stmt, 4, video_metadata->GetResolution()->GetHeight());
				sqlite3_step(stmt);
				reset_stmt(stmt);
			}
			if (video_metadata->GetColor()) {
				stmt = m_prepared["new_meta_video_color"];
				sqlite3_bind_int	(stmt, 1, film_id);
				sqlite3_bind_int	(stmt, 2, stream_id);
				sqlite3_bind_text	(stmt, 3, video_metadata->GetColor()->GetPrimaries()->c_str(), -1, SQLITE_STATIC);
				sqlite3_bind_text	(stmt, 4, video_metadata->GetColor()->GetMatrix()->c_str(), -1, SQLITE_STATIC);
				sqlite3_bind_text	(stmt, 5, video_metadata->GetColor()->GetTransfer()->c_str(), -1, SQLITE_STATIC);
				sqlite3_bind_text	(stmt, 6, video_metadata->GetColor()->GetPixelFormat()->c_str(), -1, SQLITE_STATIC);
				sqlite3_step(stmt);
				reset_stmt(stmt);
			}
			if (video_metadata->GetHDR10()) {
				stmt = m_prepared["new_meta_video_hdr10"];
				sqlite3_bind_int	(stmt, 1, film_id);
				sqlite3_bind_int	(stmt, 2, stream_id);
				// red_x, red_y, green_x, green_y, blue_x, blue_y, white_x, white_y, lum_min, lum_max, light_max, light_avg, has_plus
				sqlite3_bind_int	(stmt, 3, video_metadata->GetHDR10()->GetRedPoint().first);
				sqlite3_bind_int	(stmt, 4, video_metadata->GetHDR10()->GetRedPoint().second);
				sqlite3_bind_int	(stmt, 5, video_metadata->GetHDR10()->GetGreenPoint().first);
				sqlite3_bind_int	(stmt, 6, video_metadata->GetHDR10()->GetGreenPoint().second);
				sqlite3_bind_int	(stmt, 7, video_metadata->GetHDR10()->GetBluePoint().first);
				sqlite3_bind_int	(stmt, 8, video_metadata->GetHDR10()->GetBluePoint().second);
				sqlite3_bind_int	(stmt, 9, video_metadata->GetHDR10()->GetWhitePoint().first);
				sqlite3_bind_int	(stmt, 10, video_metadata->GetHDR10()->GetWhitePoint().second);
				sqlite3_bind_int	(stmt, 11, video_metadata->GetHDR10()->GetLuminance().first);
				sqlite3_bind_int	(stmt, 12, video_metadata->GetHDR10()->GetLuminance().second);
				if (video_metadata->GetHDR10()->GetLightLevel()) {
					sqlite3_bind_int	(stmt, 13, video_metadata->GetHDR10()->GetLightLevel()->first);
					sqlite3_bind_int	(stmt, 14, video_metadata->GetHDR10()->GetLightLevel()->second);
				}
				else {
					sqlite3_bind_null	(stmt, 13);
					sqlite3_bind_null	(stmt, 14);
				}
				sqlite3_step(stmt);
				reset_stmt(stmt);
			}
		}
		else if (stream_type == "s") {
			/* Subtitle stream */
			std::shared_ptr<Media::Subtitle::Stream> subtitle_stream = std::dynamic_pointer_cast<Media::Subtitle::Stream>(*it);
			std::shared_ptr<Media::Subtitle::Metadata> subtitle_metadata = std::dynamic_pointer_cast<Media::Subtitle::Metadata>(subtitle_stream->GetMetadata());
			stmt = m_prepared["new_meta_subtitle"];
			sqlite3_bind_int	(stmt, 1, film_id);
			sqlite3_bind_int	(stmt, 2, stream_id);
			sqlite3_bind_text	(stmt, 3, subtitle_metadata->GetString().c_str(), -1, SQLITE_STATIC);
			sqlite3_step(stmt);
			reset_stmt(stmt);
		}
	}

	commit_transaction();
	return film_id;
}

bool SQLite3::check_database() {
	char* err_msg = NULL;
	int rc = sqlite3_exec(m_database, "SELECT * FROM films;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
	return rc == SQLITE_OK;
}

void SQLite3::init_database() {
	char* err_msg = NULL;
	int rc = sqlite3_exec(m_database, DATABASE_CREATE_SQL.c_str(), nullptr, nullptr, &err_msg);
	if (rc != SQLITE_OK) throw_error(err_msg);
}

void SQLite3::enable_foreign_keys() {
	char* err_msg = NULL;
	sqlite3_exec(m_database, "PRAGMA foreign_keys = OFF", nullptr, nullptr, &err_msg);
}

void SQLite3::throw_error(char* err_msg) {
	const std::string message = "Error creating database: " + std::string(err_msg);
	sqlite3_free(err_msg);
	throw std::runtime_error(message);
}

void SQLite3::reset_stmt(sqlite3_stmt* stmt) {
	sqlite3_clear_bindings(stmt);
	sqlite3_reset(stmt);
}

void SQLite3::begin_transaction() {
	char* err_msg = nullptr;
	sqlite3_exec(m_database, "BEGIN TRANSACTION;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
}

void SQLite3::begin_exclusive_transaction() {
	char* err_msg = nullptr;
	sqlite3_exec(m_database, "BEGIN EXCLUSIVE TRANSACTION;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
}

void SQLite3::commit_transaction() {
	char* err_msg = nullptr;
	sqlite3_exec(m_database, "COMMIT;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
}

void SQLite3::rollback_transaction() {
	char* err_msg = nullptr;
	sqlite3_exec(m_database, "ROLLBACK;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
}

void SQLite3::prepare_sentences() {
	for (auto it = DATABASE_PREPARED_SENTENCES.begin(); it != DATABASE_PREPARED_SENTENCES.end(); it++) {
		m_prepared[it->first] = nullptr;
		sqlite3_prepare_v2( m_database, it->second.c_str(), it->second.length(), &m_prepared[it->first], nullptr);
		if (!m_prepared[it->first])
			throw std::runtime_error("Prepared sentence " + (it->first) + " can not be loaded!");
	}
}
