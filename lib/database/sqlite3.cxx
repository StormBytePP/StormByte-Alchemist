#include "sqlite3.hxx"
#include "generated/database_create.hxx" // Autogenerated by CMake

#include <stdexcept>

using namespace Alchemist::Database;

const std::map<std::string, std::string> SQLite3::DATABASE_PREPARED_SENTENCES = {
};

SQLite3::SQLite3(const std::filesystem::path& dbfile) {
	int rc = sqlite3_open(dbfile.c_str(), &m_database);

	if (rc != SQLITE_OK) {
		const std::string message = "Cannot open database " + dbfile.string() + ": " + std::string(sqlite3_errmsg(m_database));
		sqlite3_close(m_database); // Need to close database here as exception throwing will skip destructor
        throw std::runtime_error(message);
    }
	if (!check_database()) init_database();
	enable_foreign_keys();
	prepare_sentences();
	
}

SQLite3::~SQLite3() {
	for (auto it = m_prepared.begin(); it != m_prepared.end(); it++) {
		sqlite3_finalize(it->second);
	}
	m_prepared.clear();
	sqlite3_close(m_database);
}

bool SQLite3::check_database() {
	char* err_msg = NULL;
	int rc = sqlite3_exec(m_database, "SELECT * FROM films;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
	return rc == SQLITE_OK;
}

void SQLite3::init_database() {
	char* err_msg = NULL;
	int rc = sqlite3_exec(m_database, DATABASE_CREATE_SQL.c_str(), nullptr, nullptr, &err_msg);
	if (rc != SQLITE_OK) throw_error(err_msg);
}

void SQLite3::enable_foreign_keys() {
	char* err_msg = NULL;
	sqlite3_exec(m_database, "PRAGMA foreign_keys = OFF", nullptr, nullptr, &err_msg);
}

void SQLite3::throw_error(char* err_msg) {
	const std::string message = "Error creating database: " + std::string(err_msg);
	sqlite3_free(err_msg);
	throw std::runtime_error(message);
}

void SQLite3::reset_stmt(sqlite3_stmt* stmt) {
	sqlite3_clear_bindings(stmt);
	sqlite3_reset(stmt);
}

void SQLite3::begin_transaction() {
	char* err_msg = nullptr;
	sqlite3_exec(m_database, "BEGIN TRANSACTION;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
}

void SQLite3::begin_exclusive_transaction() {
	char* err_msg = nullptr;
	sqlite3_exec(m_database, "BEGIN EXCLUSIVE TRANSACTION;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
}

void SQLite3::commit_transaction() {
	char* err_msg = nullptr;
	sqlite3_exec(m_database, "COMMIT;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
}

void SQLite3::rollback_transaction() {
	char* err_msg = nullptr;
	sqlite3_exec(m_database, "ROLLBACK;", nullptr, nullptr, &err_msg);
	sqlite3_free(err_msg);
}

void SQLite3::prepare_sentences() {
	for (auto it = DATABASE_PREPARED_SENTENCES.begin(); it != DATABASE_PREPARED_SENTENCES.end(); it++) {
		m_prepared[it->first] = nullptr;
		sqlite3_prepare_v2( m_database, it->second.c_str(), it->second.length(), &m_prepared[it->first], nullptr);
		if (!m_prepared[it->first])
			throw std::runtime_error("Prepared sentence " + (it->first) + " can not be loaded!");
	}
}
