#include <Alchemy/path.hxx>
#include <Alchemy/config/file.hxx>
#include <StormByte/system/variable.hxx>

#include "generated/default_config.hxx" // Generated by CMake

using namespace Alchemy::Config;
using namespace StormByte;
using Item 	= StormByte::Config::Item;
using Group = StormByte::Config::Group;

const std::string Alchemy::Config::File::DEFAULT_CONFIG = ALCHEMY_DEFAULT_CONFIG;

File& File::Instance() {
	static File instance { GetFilePath() };

	return instance;
}

File::File(const std::filesystem::path& path):StormByte::Config::File(path) { Initialize(); }

const std::filesystem::path File::GetDatabaseFile() const {
	return System::Variable::Expand(Child("database")->AsString());
}

void File::SetDatabaseFile(const std::filesystem::path& dbfile) {
	Child("database")->SetString(dbfile.string());
}

const std::filesystem::path File::GetTmpDirectory() const {
	return System::Variable::Expand(Child("tmpdir")->AsString());
}

void File::SetTmpDirectory(const std::filesystem::path& tmpdir) {
	Child("tmpdir")->SetString(tmpdir.string());
}

int File::GetSleepTime() const {
	return Child("sleep")->AsInteger();
}

void File::SetSleepTime(const int& sleep) {
	Child("sleep")->SetInteger(sleep);
}

std::optional<Codec> File::GetCodec(const std::string& codec) const {
	std::optional<Codec> codec_cfg;
	try {
		auto item = LookUp("codec/" + codec);
		codec_cfg = { codec };
		if (item->AsGroup().Exists("bitrate"))
			codec_cfg->c_bitrate = item->AsGroup().Child("bitrate")->AsInteger();
		if (item->AsGroup().Exists("options"))
			codec_cfg->c_options = item->AsGroup().Child("options")->AsString();
	}
	catch(...) { /* Ignored */ }
	return codec_cfg;
}

void File::SetCodec(const Codec& codec_cfg) {
	auto codec_group = Child("codec");
	if (codec_group->AsGroup().Exists(codec_cfg.c_name))
		codec_group->AsGroup().Remove(codec_cfg.c_name);
	
	/* We only add the item if there is at least one valid */
	if (codec_cfg.c_bitrate || codec_cfg.c_options) {
		if (codec_cfg.c_bitrate)
			codec_group->AsGroup().Add("bitrate", Item::Type::Integer)->SetInteger(*codec_cfg.c_bitrate);
		if (codec_cfg.c_options)
			codec_group->AsGroup().Add("options", Item::Type::String)->SetString(*codec_cfg.c_options);
	}
}

void File::PostRead() noexcept {
	/* Here we check validity of the successfully read config file */
	auto new_root = std::make_unique<Group>("root"); // Name is unrelevant

	if (Exists("database") && Child("database")->GetType() == Item::Type::String)
		new_root->Add(Child("database"));
	else {
		#ifdef WINDOWS
		new_root->Add("database", Item::Type::String)->SetString("%PROGRAMDATA%\\\\database.sqlite");
		#else
		new_root->Add("database", Item::Type::String)->SetString("~/database.sqlite");
		#endif
	}

	if (Exists("tmpdir") && Child("tmpdir")->GetType() == Item::Type::String)
		new_root->Add(Child("tmpdir"));
	else {
		#ifdef WINDOWS
		new_root->Add("tmpdir", Item::Type::String)->SetString("%TEMP%");
		#else
		new_root->Add("tmpdir", Item::Type::String)->SetString("/tmp");
		#endif
	}

	if (Exists("sleep") && Child("sleep")->GetType() == Item::Type::Integer)
		new_root->Add(Child("sleep"));
	else
		new_root->Add("sleep", Item::Type::Integer)->SetInteger(60);

	auto new_codec_root = new_root->Add("codec", Item::Type::Group);
	if (Exists("codec") && Child("codec")->GetType() == Item::Type::Group) {
		for (auto it = Child("codec")->AsGroup().Begin(); it != Child("codec")->AsGroup().End(); it++) {
			auto new_codec_item = std::make_shared<Group>(it->GetName());
			if (it->AsGroup().Exists("bitrate") && it->AsGroup().Child("bitrate")->GetType() == Item::Type::String)
				new_codec_item->Add("bitrate", Item::Type::String)->SetString(it->AsGroup().Child("bitrate")->AsString());
			if (it->AsGroup().Exists("options") && it->AsGroup().Child("options")->GetType() == Item::Type::String)
				new_codec_item->Add("options", Item::Type::String)->SetString(it->AsGroup().Child("options")->AsString());
			if (it->AsGroup().Exists("ffmpeg") && it->AsGroup().Child("ffmpeg")->GetType() == Item::Type::Group) {
				auto codec_ffmpeg = new_codec_item->Add("ffmpeg", Item::Type::Group);
				for (auto ffmpeg_it = it->AsGroup().Begin(); ffmpeg_it != it->AsGroup().End(); ffmpeg_it++)
					codec_ffmpeg->AsGroup().Add(ffmpeg_it->GetName(), Item::Type::String)->SetString(ffmpeg_it->AsString());
			}

			if (new_codec_item->Exists("bitrate") || new_codec_item->Exists("options"))
				new_codec_root->AsGroup().Add(new_codec_item);
		}
	}
	else {
		// Reconstruct with default values
		std::shared_ptr<Group> codec;
		std::shared_ptr<Group> ffmpeg;

		// Default for fdk_aac
		codec = std::make_shared<Group>("fdk_aac");
		codec->Add("bitrate", Item::Type::Integer)->SetInteger(128);
		ffmpeg = std::dynamic_pointer_cast<Group>(codec->Add("ffmpeg", Item::Type::Group));
		ffmpeg->Add("profile", Item::Type::String)->SetString("aac_he");
		new_codec_root->AsGroup().Add(codec);

		// Default for libopus
		codec = std::make_shared<Group>("libopus");
		codec->Add("bitrate", Item::Type::Integer)->SetInteger(96);
		new_codec_root->AsGroup().Add(codec);


		// Default for libx265
		codec = std::make_shared<Group>("libx265");
		codec->Add("options", Item::Type::String)->SetString("level=5.1:crf=24:ref=4:hme=1:hme-search=umh,umh,star:subme=4:bframes=8:rd=4:rd-refine=0:qcomp=0.65:fades=1:strong-intra-smoothing=1:ctu=32:qg-size=32:aq-mode=4:sao=1:selective-sao=2:rdoq-level=1:psy-rd=4.0:psy-rdoq=15.0:limit-modes=0:limit-refs=0:limit-tu=0:weightb=1:weightp=1:rect=1:amp=1:wpp=1:pmode=0:pme=0:b-intra=1:b-adapt=2:b-pyramid=1:vbv-bufsize=160000:vbv-maxrate=160000:log-level=error");
		new_codec_root->AsGroup().Add(codec);
	}

	m_root = std::move(new_root);
	Write();
}

const std::filesystem::path File::GetFilePath() {
	return Path::Conf() / "config";
}

void File::Initialize() {
	if (!std::filesystem::exists(Path::Conf())) {
		/* If there is no path there is no config neither */
		std::filesystem::create_directory(Path::Conf());
		ReadFromString(DEFAULT_CONFIG);
	}
	else if (!std::filesystem::exists(GetFilePath())) {
		ReadFromString(DEFAULT_CONFIG);
	}
	else {
		try {
			Read();
		}
		catch(const StormByte::Config::Exception&) {
			ReadFromString(DEFAULT_CONFIG);
		}
	}
}
